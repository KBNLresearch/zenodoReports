#! /usr/bin/env python3

"""
Analyses Zenodo JSON file generated by fetch.py, and generates reports in Markdown and HTML
"""

import sys
import os
import shutil
import codecs
import json
import datetime
from dateutil import rrule
import pandas as pd
import numpy as np
from matplotlib import pylab
from matplotlib import pyplot as plt
from matplotlib import dates as mdates
from matplotlib.dates import DateFormatter
import markdown
from tabulate import tabulate

# Set defaults for pyplot
params = {'legend.fontsize': 'large',
          'figure.figsize': (16, 9),
         'axes.labelsize': '18',
         'axes.titlesize':'large',
         'xtick.labelsize':'x-large',
         'ytick.labelsize':'x-large'}
pylab.rcParams.update(params)

def dfToMarkdown(dataframe, headers='keys'):
    """Convert Data Frame to Markdown table with optionally custom headers"""
    mdOut = dataframe.pipe(tabulate, headers=headers, tablefmt='pipe')
    return mdOut


def iterateAggregation(aggregation):
    """Iterate over aggregation elements and return output table as list"""
    buckets = aggregation["buckets"]
    countOther = aggregation["sum_other_doc_count"]

    outTable = []

    for bucket in buckets:
        doc_count = bucket["doc_count"]
        key = bucket["key"]
        outTable.append([key, doc_count])

    outTable.append(['other', countOther])

    return outTable


def reportAccessRights(aggregations):
    """Report access right info"""
    access_right = aggregations["access_right"]
    outTable = iterateAggregation(access_right)

    # Create summary table
    tableHeader = ['Access type', 'Number of publications']

    mdString = '\n\n## Access rights\n\n'
    mdString += tabulate(outTable, tableHeader, tablefmt='pipe')

    return mdString


def reportFileTypes(aggregations):
    """Report file type info"""
    file_type = aggregations["file_type"]
    outTable = iterateAggregation(file_type)

    # Create summary table
    tableHeader = ['File type', 'Number of files']

    mdString = '\n\n## File types\n\n'
    mdString += tabulate(outTable, tableHeader, tablefmt='pipe')

    return mdString


def reportKeywords(aggregations):
    """Report keyword info"""
    keywords = aggregations["keywords"]
    outTable = iterateAggregation(keywords)

    # Create summary table
    tableHeader = ['Keyword', 'Number of publications']

    mdString = '\n\n## Keywords\n\n'
    mdString += tabulate(outTable, tableHeader, tablefmt='pipe')

    return mdString


def reportPublicationTypes(aggregations):
    """Report publication type info"""
    type = aggregations["type"]
    outTable = iterateAggregation(type)

    # Create summary table
    tableHeader = ['Publication type', 'Number of publications']

    mdString = '\n\n## Publication types\n\n'
    mdString += tabulate(outTable, tableHeader, tablefmt='pipe')

    return mdString


def reportCreatedDates(createdDates):
    """Report created dates info"""
    cDates = []
    # First convert ISO datetime strings to date values
    for createdDate in createdDates:
        cDates.append(datetime.datetime.fromisoformat(createdDate).date())
    
    # Sort dates and get lower/upper bounds
    cDates.sort()
    yearMin = cDates[0].year
    monthMin = cDates[0].month
    yearMax = cDates[len(cDates) - 1].year
    monthMax = cDates[len(cDates) - 1].month

    # List of all months between dateMin and dateMax
    createdRange = []

    year = yearMin
    month = monthMin

    while year <= yearMax:
        myDate = datetime.date(year, month, 1)
        createdRange.append(myDate)
        if year == yearMax:
            if month < monthMax:
                month += 1
            else:
                # Increase year index to force break from loop
                year += 1
        else:
            month +=1
        if month > 12:
            month = 1
            year += 1

        createdCounts = []
        createdCountsCum = []

    countCumPrev = 0

    # For each month in createdRange, count number of publications
    # and keep track of cumulative count
    for created in createdRange:
        count = 0
        for date in cDates:
            if date.year == created.year and date.month == created.month:
                count += 1
        createdCounts.append(count)
        countCum = countCumPrev + count
        createdCountsCum.append(countCum)
        countCumPrev = countCum

    dirImg = "."
    dirCSV = "."

    cDatesFrame = pd.DataFrame({'date': createdRange,
                                'noPubs': createdCounts,
                                'noPubsCum': createdCountsCum})

    # Note: setting 'kind' to 'box' below results in weird
    # behaviour of date_form (all years are set to 1970!)
    # Might be related to this bug: https://github.com/pandas-dev/pandas/issues/26253

    pubsPlot = cDatesFrame.plot(kind='line',
                                x='date',
                                y='noPubsCum',
                                lw=2.5,
                                figsize=(16,9))

    date_form = DateFormatter("%Y-%m")
    pubsPlot.axes.xaxis.set_major_formatter(date_form)

    locator = mdates.AutoDateLocator(minticks = 16, maxticks = 24)
    formatter = mdates.ConciseDateFormatter(locator)
    formatter.formats = ['%Y', '%b', '%d']

    pubsPlot.axes.xaxis.set_major_locator(locator)
    pubsPlot.axes.xaxis.set_major_formatter(formatter)

    pubsPlot.set_xlabel('Datum')
    pubsPlot.set_ylabel('Publicaties (cumulatief)')
    pubsPlot.set_xlim([datetime.date(yearMin, 1, 1), datetime.date(yearMax, 12, 31)])
    pubsPlot.get_legend().remove()
    fig = pubsPlot.get_figure()
    fig.savefig(os.path.join(dirImg, 'pubsTimeCum.png'))

    # Export data frame to a CSV file
    cDatesFrame.to_csv(os.path.join(dirCSV, 'pubsTime.csv'), encoding='utf-8', index=False)
 

def reportPublicationDates(publicationDates):
    """Report publication dates info"""
    pubDates = []
    for publicationDate in publicationDates:
        pubDates.append(datetime.date.fromisoformat(publicationDate))
    print(pubDates)

def report(fileIn):
    """Create report from JSON file"""

    # Initialize empty string for Markdown output
    reportString = ""

    # Read JSON file
    with open(fileIn, 'r') as f:
        dataIn = json.load(f)

    # Report aggregated statistics
    aggregations = dataIn["aggregations"]
    mdString = reportAccessRights(aggregations)
    reportString += mdString
    mdString = reportFileTypes(aggregations)
    reportString += mdString
    mdString = reportKeywords(aggregations)
    reportString += mdString
    mdString = reportPublicationTypes(aggregations)
    reportString += mdString
 
    # Report detailed statistics from individual hits
    hits = dataIn["hits"]["hits"]
    createdDates = []
    fileTypes = []
    accessRights = []
    keyWords = []
    languages = []
    licenses = []
    publicationDates = []
    resourceTypes = []
    resourceSubtypes = []

    for hit in hits:
        created = hit["created"]
        createdDates.append(created)
        try:
            files = hit["files"]
        except KeyError:
            # Closed access publications can have no files
            files = []
        for file in files:
            ftype = file["type"]
            fileTypes.append(ftype)
        metadata = hit["metadata"]
        access_right = metadata["access_right"]
        accessRights.append(access_right)
        try:
            keywords = metadata["keywords"]
        except KeyError:
            keywords = []
        for keyword in keywords:
            keyWords.append(keyword)
        try:
            language = metadata["language"]
            languages.append(language)
        except KeyError:
            languages.append("N/A")
        try:
            license = metadata["license"]["id"]
            licenses.append(license)
        except KeyError:
            licenses.append("N/A")
        try:
            publicationDate = metadata["publication_date"]
            publicationDates.append(publicationDate)
        except KeyError:
            publicationDates.append("N/A")
        resource_type = metadata["resource_type"]
        
        try:
            type = resource_type["type"]
            resourceTypes.append(type)
        except KeyError:
            pass
        try:
            subtype = resource_type["subtype"]
            resourceSubtypes.append(subtype)
        except KeyError:
            pass

    reportCreatedDates(createdDates)

